"""
   ______                              _______
  / _____)                        _   (_______)                 _
 ( (____   ____   _____   ____  _| |_  _        _____  ____   _| |_   ___   ____
  \____ \ |    \ (____ | / ___)(_   _)| |      (____ ||  _ \ (_   _) / _ \ |  _ \
  _____) )| | | |/ ___ || |      | |_ | |_____ / ___ || | | |  | |_ | |_| || | | |
 (______/ |_|_|_|\_____||_|       \__) \______)\_____||_| |_|   \__) \___/ |_| |_|
  ______                 ______
 (______)               (____  \
  _     _  _____  _   _  ____)  )  ___   _   _
 | |   | || ___ || | | ||  __  (  / _ \ ( \ / )
 | |__/ / | ____| \ V / | |__)  )| |_| | ) X (
 |_____/  |_____)  \_/  |______/  \___/ (_/ \_)

@author  Da Silva Andrade David
@version V1.0
@date    02-01-2018
@brief   The purpose of this server is to SmartCanton DevBox device. Each device is stored in a database (sqlite) and
         with his information, such has, his BLE mac address, LoRa DevEUI and the more important, the App Key that is
         used by the LoRaWAN module to join/write/read from a LoRaWAN network. The access to these information require
         an authenticated user. Users can only be created by admin users. The admins have access to all the devices.
         Non admin users can only see their own devices.
         The access to the REST api is protected by a JWT token. The token need to be generated by the route '/auth' and
         then provided for all the next connexions. The server needs SSL certificates to operates, these certificates
         need to be placed in a directory named "ssl_certificates".
"""

import uuid
from datetime import timedelta
import ssl
import os

from flask import Flask, request, jsonify
from flask_jwt_extended import JWTManager, jwt_required, create_access_token, get_jwt_identity
from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import generate_password_hash, check_password_hash

app = Flask(__name__)

"""
Provide a SQLite database, with the following format : 
create table smartcanton_devbox_device
(
	id INTEGER
		primary key
		 autoincrement,
	device_eui CHAR(16),
	app_eui CHAR(16),
	app_key CHAR(32),
	owner_id INTEGER,
	ble_passkey VARCHAR(16),
	ble_mac_addr CHAR(16)
)
;

create unique index lora_device_device_eui_uindex
	on smartcanton_devbox_device (device_eui)
;

create table user
(
	id INTEGER not null
		primary key,
	public_id VARCHAR(50)
		unique,
	name VARCHAR(50),
	password VARCHAR(80),
	admin BOOLEAN,
	check (admin IN (0, 1))
)
;

alter table smartcanton_devbox_device
	add constraint lora_device_user_id_fk
		foreign key (owner_id) references user (id)
;
"""
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///smartcanton_users_devices.db'

"""
Key used to generate the JWT token. Change it to your wanted secret key
"""
app.config['SECRET_KEY'] = '<YOUR_SECRET_KEY_HERE>'
db = SQLAlchemy(app)

"""
JWT Token configuration
"""
app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(days=30)
app.config['JWT_HEADER_TYPE'] = "JWT"
app.config['JWT_IDENTITY_CLAIM'] = "public_id"

"""
Provide your own keys to sign the SSL connexion
"""
context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
chain_path = 'ssl_certificates/fullchain.pem'
chain_path = os.path.join(os.path.dirname(__file__), chain_path)
privkey_path = 'ssl_certificates/privkey.pem'
privkey_path = os.path.join(os.path.dirname(__file__), privkey_path)
context.load_cert_chain(chain_path, privkey_path)

"""
Start the JWT manager with the parameters set before
"""
jwt = JWTManager(app)


class User(db.Model):
    """
    Model representing an entry in the User table
    """
    id = db.Column(db.Integer, primary_key=True)
    public_id = db.Column(db.String(50), unique=True)
    name = db.Column(db.String(50))
    password = db.Column(db.String(80))
    admin = db.Column(db.Boolean)


class SmartcantonDevboxDevice(db.Model):
    """
    Model representing an entry in the SmartcantonDevboxDevice table
    """
    id = db.Column(db.Integer, primary_key=True)
    device_eui = db.Column(db.CHAR(16), unique=True)
    app_eui = db.Column(db.CHAR(16))
    app_key = db.Column(db.CHAR(32))
    ble_mac_addr = db.Column(db.CHAR(32))
    ble_passkey = db.Column(db.String(16))
    owner_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    owner = db.relationship('User', foreign_keys=owner_id)


@app.route('/', methods=['GET'])
def hello():
    """
    Route to the root path of the WebServer.

    @return: A message to be sure that the WebServer is running correctly
    """
    return "hello!"


@app.route('/auth', methods=['POST'])
def login():
    """
    Provide a method to create access tokens. The create_access_token() function is used to actually generate the token,
    and you can return it to the caller however you choose.

    @return: Http code 200 and an access token token in a JSON if the login is successful
    """
    if not request.is_json:
        return jsonify({"message": "Missing JSON in request"}), 400

    try:
        username = request.json.get('username', None)
        password = request.json.get('password', None)
    except:
        username = None
        password = None

    if not username:
        return jsonify({"message": "Missing username parameter"}), 400
    if not password:
        return jsonify({"message": "Missing password parameter"}), 400

    user = User.query.filter_by(name=username).first()

    # If user exist and password correct
    if (user is None) or (not check_password_hash(user.password, password)):
        # if username != 'test' or password != 'test':
        return jsonify({"message": "Bad username or password"}), 401

    # Identity can be any data that is json serializable
    access_token = create_access_token(identity=user.public_id)
    return jsonify(access_token=access_token), 200


def user_from_public_id(public_id):
    """
    Get from the database the username from a given public ID

    @param public_id: An UUID defining an user
    @return: A User object defining an user
    """
    try:
        current_identity = User.query.filter_by(public_id=public_id).first()
        return current_identity
    except:
        return User.query.filter_by(public_id).first()


@app.route('/user', methods=['GET'])
@jwt_required
def get_all_users():
    """
    Request the list of all available users on the server. Only a user with Admin rights can call this route.

    @return: A list of all the users found with their information
    """
    if not user_from_public_id(get_jwt_identity()).admin:
        return jsonify({'message': 'Cannot perform that function with your rights!'}), 403

    users = User.query.all()

    output = []

    for user in users:
        user_data = {}
        user_data['public_id'] = user.public_id
        user_data['name'] = user.name
        user_data['password'] = user.password
        user_data['admin'] = user.admin
        output.append(user_data)

    return jsonify({'users': output})


@app.route('/user/<public_id>', methods=['GET'])
@jwt_required
def get_one_user(public_id):
    """
    Get all details from a specific user giving his public ID. Require the admin rights if the current logged user isn't
    the one that is requesting the access.

    @param public_id: An UUID defining an user
    @return: All the information about the requested user if he is found in the database
    """
    if not user_from_public_id(get_jwt_identity()).admin:
        if not user_from_public_id(get_jwt_identity()).public_id == public_id:
            return jsonify({'message': 'Cannot perform that function!'}), 403

    user = User.query.filter_by(public_id=public_id).first()

    if not user:
        return jsonify({'message': 'No user found!'}), 403

    user_data = {}
    user_data['public_id'] = user.public_id
    user_data['username'] = user.name
    # user_data['password'] = user.password
    user_data['admin'] = user.admin

    # return jsonify({'user': user_data})
    return jsonify(user_data)


@app.route('/user', methods=['POST'])
@jwt_required
def create_user():
    """
    Create a new user specifying his username, password and if he is an admin or not. Only a user with Admin rights can
    call this route.

    @return: HTTP code 200 and the message "message': 'New user created!'" if everything is successful
    """
    if not user_from_public_id(get_jwt_identity()).admin:
        return jsonify({'message': 'Cannot perform that function!'}), 403

    data = request.get_json()

    hashed_password = generate_password_hash(data['password'], method='sha256')

    new_user = User(public_id=str(uuid.uuid4()), name=data['username'], password=hashed_password, admin=False)
    db.session.add(new_user)
    db.session.commit()

    return jsonify({'message': 'New user created!'})


@app.route('/user/<public_id>', methods=['PUT'])
@jwt_required
def change_user_information(public_id):
    """
    Change all the details to a existing user. Require the admin rights if the current logged user isn't
    the one that is requesting the access.

    @param public_id: An UUID defining an user
    @return: HTTP code 200 and the message "message': 'User information updated!'" if everything is successful
    """
    # if not user_from_public_id(get_jwt_identity()).admin:
    #     return jsonify({'message': 'Cannot perform that function!'}), 403

    user = User.query.filter_by(public_id=public_id).first()

    if not user:
        return jsonify({'message': 'No user found!'}), 404

    try:
        data = request.get_json()
        print(data)
    except:
        return jsonify({'message': 'Wrongly formed JSON!'}), 400

    try:
        if ('new_password' in data) and data['new_password']:
            new_hashed_password = generate_password_hash(data['new_password'], method='sha256')
        else:
            return jsonify({'message': 'New password not valid!'}), 400
    except:
        return jsonify({'message': 'New password not valid!'}), 400

    # If the current JWT identity is an admin, we don't need to know the password to update a new password
    if user_from_public_id(get_jwt_identity()).admin:
        if 'new_password' in data:
            user.password = new_hashed_password
        if 'admin' in data:
            user.admin = data['admin']
    # Else if the authenticated user is the one updated
    elif user_from_public_id(get_jwt_identity()).public_id == user.public_id:
        if 'new_password' in data:
            if check_password_hash(user.password, data['password']):
                user.password = new_hashed_password
            else:
                return jsonify({'message': 'Wrong password!'}), 404
    else:
        return jsonify({'message': 'Cannot perform that function!'}), 403

    db.session.commit()

    return jsonify({'message': 'User information updated!'})


@app.route('/user/<public_id>', methods=['DELETE'])
@jwt_required
def delete_user(public_id):
    """
    Delete an user by specifying his public id. Only a user with Admin rights can call this route.

    @param public_id: An UUID defining an user
    @return: HTTP code 200 and the message "message': 'The user has been deleted!'" if everything is successful
    """
    if not user_from_public_id(get_jwt_identity()).admin:
        return jsonify({'message': 'Cannot perform that function!'}), 403

    user = User.query.filter_by(public_id=public_id).first()

    if not user:
        return jsonify({'message': 'No user found!'}), 400

    db.session.delete(user)
    db.session.commit()

    return jsonify({'message': 'The user has been deleted!'})


@app.route('/device', methods=['GET'])
@jwt_required
def get_all_devices():
    """
    Get all devices on the database if the user requesting the data is the admin. Otherwise, return only the devices
    that are owned by the current user.

    @return: List of all devices depending on the user requesting the data
    """
    if user_from_public_id(get_jwt_identity()).admin:
        devices = SmartcantonDevboxDevice.query.all()
    else:
        user = user_from_public_id(get_jwt_identity())
        devices = SmartcantonDevboxDevice.query.filter_by(owner_id=user.id).all()

    output = []

    for device in devices:
        device_data = {}
        device_data['dev_eui'] = device.device_eui
        device_data['ble_mac_addr'] = device.ble_mac_addr
        output.append(device_data)

    return jsonify({'devices': output})


@app.route('/device/<ble_mac_addr>', methods=['GET'])
@jwt_required
def get_one_device_mac_addr(ble_mac_addr):
    """
    Get one SmartCanton DevBox device information.

    @param ble_mac_addr: Bluetooth MAC address of the SmartCanton DevBox
    @return: All the information stored about the device (dev_eui, app_eui, app_key, owner_public_id, ble_mac_addr and
             ble_passkey).
    """
    if user_from_public_id(get_jwt_identity()).admin:
        device = SmartcantonDevboxDevice.query.filter_by(ble_mac_addr=ble_mac_addr).first()
    else:
        user = user_from_public_id(get_jwt_identity())
        device = SmartcantonDevboxDevice.query.filter_by(ble_mac_addr=ble_mac_addr,
                                                         owner_id=user).first()

    if not device:
        return jsonify({'message': 'Device NOT found!'}), 400

    device_data = {}
    device_data['dev_eui'] = device.device_eui
    device_data['app_eui'] = device.app_eui
    device_data['app_key'] = device.app_key
    device_data['owner_public_id'] = User.query.filter_by(id=device.owner_id).first().public_id
    device_data['ble_mac_addr'] = device.ble_mac_addr
    device_data['ble_passkey'] = device.ble_passkey

    return jsonify(device_data)


@app.route('/device', methods=['POST'])
@jwt_required
def create_device():
    """
    Create a new device on the database. The ownership of the device is directly givien to the connected user.

    @return: HTTP code 200 and the message "message': "New device created!" if everything is successful
    """
    try:
        data = request.get_json()
    except:
        return jsonify({'message': 'Wrongly formed JSON!'}), 400

    try:
        new_device = SmartcantonDevboxDevice(device_eui=data['dev_eui'],
                                             app_eui=data['app_eui'],
                                             app_key=data['app_key'],
                                             ble_passkey=data['ble_passkey'],
                                             ble_mac_addr=data['ble_mac_addr'],
                                             owner_id=User.query.filter_by(
                                                 public_id=data['owner_public_id']).first().id)
    except:
        return jsonify({'message': "New device could NOT be created!"}), 403

    try:
        db.session.add(new_device)
        db.session.commit()
    except:
        return jsonify({'message': "Device already present inside the database!"}), 403

    return jsonify({'message': "New device created!"})


@app.route('/device/<ble_mac_addr>', methods=['PUT'])
@jwt_required
def update_device(ble_mac_addr):
    """
    Edit an existing device in the database. Admin users can edit all devices. Non admin users can only edit their own
    devices.

    @param ble_mac_addr: Bluetooth MAC address of a SmartCanton DevBox
    @return: HTTP code 200 and the message "message': "New device created!" if everything is successful
    """
    try:
        data = request.get_json()
    except:
        return jsonify({'message': 'Wrongly formed JSON!'}), 400

    if user_from_public_id(get_jwt_identity()).admin:
        device = SmartcantonDevboxDevice.query.filter_by(ble_mac_addr=ble_mac_addr).first()
    else:
        user = user_from_public_id(get_jwt_identity())
        device = SmartcantonDevboxDevice.query.filter_by(ble_mac_addr=ble_mac_addr,
                                                         owner_id=user.id).first()

    if not device:
        return jsonify({'message': 'Device not found!'}), 403

    try:
        # Test of key is in the json and if it's not empty
        if ('dev_eui' in data) and (bool(data['dev_eui'])):
            device.device_eui = data['dev_eui']
        if ('app_eui' in data) and (bool(data['app_eui'])):
            device.app_eui = data['app_eui']
        if ('app_key' in data) and (bool(data['app_key'])):
            device.app_key = data['app_key']
        if ('owner_public_id' in data) and (bool(data['owner_public_id'])):
            device.public_id = data['owner_public_id']
        if ('ble_mac_addr' in data) and (bool(data['ble_mac_addr'])):
            device.ble_mac_addr = data['ble_mac_addr']
        if ('ble_pass_key' in data) and (bool(data['ble_pass_key'])):
            device.ble_passkey = data['ble_pass_key']
    except:
        return jsonify({'message': "Device parameter not valid!"}), 401

    try:
        db.session.commit()
    except:
        return jsonify({'message': "Device parameter not valid!"}), 401

    return jsonify({'message': "New device created!"})


@app.route('/device/<ble_mac_addr>', methods=['DELETE'])
@jwt_required
def delete_device(ble_mac_addr):
    """
    Delete an existing device in the database. Admin users can delete all devices. Non admin users can only edit their
    own devices.

    @param ble_mac_addr: Bluetooth MAC address of a SmartCanton DevBox
    @return: HTTP code 200 and the message "message': "SmartCanton Devbox item deleted!" if everything is successful
    """
    if user_from_public_id(get_jwt_identity()).admin:
        device = SmartcantonDevboxDevice.query.filter_by(ble_mac_addr=ble_mac_addr).first()
    else:
        return jsonify({'message': 'Cannot perform that function!'}), 403

    if not device:
        return jsonify({'message': 'Device not found!'}), 403

    db.session.delete(device)
    db.session.commit()

    return jsonify({'message': 'SmartCanton Devbox item deleted!'})


if __name__ == '__main__':
    """
    Main task, just run flask as a web server
    """
    app.run(host='0.0.0.0', debug=True, port=5000, ssl_context=context)
